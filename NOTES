
The mind-map is a directed graph of nodes.

The user can see a chain of nodes leading up to the present one. (Ideally, the whole history of the chain would be visible if desired, but just the most recent one or two historical nodes would be visible by default.)

Of the nodes referenced by the current node, the software determines which nodes are likely to be most interesting and displays a reasonable number of them to the user.

A node has the following properties:
    A type
    An owner user id
    A title
    A "Resolved" checkbox
    Text, potentially rendered with MathJAX
    A list of nodes it has outgoing references to
    A list of nodes it contains
    A (possibly empty) reference to its parent container node
    A (possibly empty) reference to its parent workspace node
    A BLOB of attachments?
    A list recording who it's shared with.
    	For workspace nodes, this means a list of user ids.
    	For standard nodes, I'm not sure what this means. It might mean user ids, but I suspect it means a list of node ids which have been duplicated from this node in other user environments.
    An 'original owner' user id?

A node can have the following types, which mostly affect display:
    Standard: contains text, an idea, some attachments.
    Container: contains other nodes, organizes them into a coherent project. Container nodes organize the whole ATLAS universe into a tree.
    Workspace: contains other nodes, shares them in a read-write environment with other ATLAS users.

~          ~           ~

There are two kinds of sharing: collaborative workspaces and noncollaborative nodes.

Collaborative workspace: 
    A container node which is shared across users.  Nodes dropped into this workspace are visible to and can be edited by all the users on the ownership list of the workspace node.

    Question: How should one deal with allowing users to delete shared nodes?  In particular, users are allowed to have private nodes reference shared nodes. What should happen to these references if the shared node is deleted? Some ideas: 
        Shared nodes should only be allowed to be 'merged' with some other existing node. All references are updated to point to the merged node.

        'Merging' is always an option, but 'deleting' a shared node always silently means merging it with the parent workspace, so that private references don't get completely lost. Maybe bad references can be mentioned to their owner so that they have a chance to be manually updated.

        Deleting the shared node also deletes all of its references.

Noncollaborative node:
	A private node which is marked as read-only for a set selection of other users. They are allowed to make references to this node and to view its contents, but they can't edit it. This is the sort of sharing you'd want to, say, broadcast a preprint while not allowing the other users to edit it, as you're not actually part of a shared project.

	Question: How should the software deal with the owner updating a noncollaboratively shared node? Some ideas:
		Immediately copy the shared node into other people's collections, so that the node's contents are fixed and non-removable by the original owner.

		If the owner deletes the node, create copies for the other users and mark it as 'orphaned' by the original owner.

		The owner retains full control over the node, so that if they modify or delete it those changes are reflected everywhere.

		Some kind of offer system, where when the owner edits the node the other users are given the option to update their node to reflect the owner's node's new state.  (If they decline, it should be possible to change that choice later and update. If they update, I don't know whether it should be possible to revert to an old state. Probably not.)

~          ~           ~

Are there situations where you'd want two nodes to directly reference one another, or more generally are there situations where you'd want there to be a circular reference? Wouldn't it make more sense just to put such nodes in a container? (Is it always necessary that references be directed? Hm.)

~          ~           ~

Eventually we'll want to render these nodes nicely. Matt Pancia says that D3 offers a ton of smart ways to do drawing, and he suggests looking at the following URLs:

    http://d3js.org ,

    https://github.com/mbostock/d3/wiki/Tutorials .

In particular, this D3 demo contains a lot of the things we're interested in

    http://flowingdata.com/2012/08/02/how-to-make-an-interactive-network-visualization/ .

One of the tutorials also suggested the following nice book:

    http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742 .

I also found this metaball fiddle:

    http://jsfiddle.net/TscNZ/802/ .

This looks useful for drawing the glow underneath workspace nodes, so that nearby nodes that belong to the same workspace are automatically joined.

Possibly this will be helpful for organizing the graph drawing code:

    http://stackoverflow.com/questions/10887027/how-do-i-set-the-focal-node-in-a-d3-js-force-directed-graph?lq=1 ,

but using it will require not using the built-in d3.layout.force thing. You'll have to lay things out a little manually.

~          ~           ~

This seems useful for performance:

    http://mongoosejs.com/docs/api.html#query_Query-lean .

~          ~           ~

We should provide some kind of popover interim path selector.  I'm envisioning a popover div, launched by

    launchPathSelector(DOMElement, function callback(path) { ... })

which attaches itself to the DOMElement and displays a box like

    [ working path, .., n1, ..., nm ],

all clickable, which select the current path, move to the previous path, and select (or move to, if a container) one of the toplevel nodes n1, ..., nm respectively, eventually calling the callback function with the selected path (Ã  la /bulb/:id/path) on finish, to be used to update whatever needs updating.

You might look at

    http://hallofhavoc.com/2013/05/how-to-create-an-overlay-popup-box-using-html-css-and-jquery/

for how to set up one of these overlay <div>s.
